{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nuvom","text":"<p>Nuvom gives developers a task engine they can trust clean APIs, zero magic, and predictable behavior from local dev to production scale.</p> <p>Nuvom is a developer-first background task engine for Python. It lets you queue, schedule, and persist background jobs with predictable behavior without depending on heavyweight infrastructure.</p> <p>When you need more power, Nuvom\u2019s pluggable backend architecture lets you integrate with SQLite, PostgreSQL, Redis, RabbitMQ, or your own backend for advanced workflows and scaling.</p>"},{"location":"#why-nuvom","title":"Why Nuvom?","text":"<p>Nuvom is built for developers who want a clear, reliable, and flexible task system that scales with their needs \u2014 from a single-machine project to production-grade deployments.</p> <p>It\u2019s designed for:</p> <ul> <li>Developers and teams who want simplicity without giving up control</li> <li>Plugin authors who need a modular, testable task engine</li> <li>Cross-platform environments \u2014 consistent behavior on Linux, macOS, and Windows</li> <li>Predictable production workflows with static discovery, manifest caching, and clean observability</li> <li>Advanced setups that need pluggable backends for durability and scale</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Clean task API with <code>@task</code>, <code>.delay()</code>, <code>.map()</code>, and <code>.schedule()</code></li> <li>Pluggable architecture \u2014 SQLite, Postgres, Redis, RabbitMQ, or custom backends</li> <li>Static task discovery \u2014 AST-powered, no runtime imports needed</li> <li>Multiple scheduling modes \u2014 one-off (<code>at</code> / <code>in_</code>), interval, cron</li> <li>Durable job execution \u2014 retries, timeouts, and predictable failure handling</li> <li>Plugin loader with <code>.toml</code> registry for easy extension</li> <li>Observability built-in \u2014 job metadata, tracebacks, and optional Prometheus metrics</li> <li>Typed configuration via <code>.env</code> and Pydantic</li> <li>Cross-platform \u2014 Python 3.8+ on Linux, macOS, and Windows</li> </ul>"},{"location":"#example-scheduling-a-task","title":"Example: Scheduling a Task","text":"<pre><code>from datetime import timedelta\nfrom nuvom.task import task\n\n@task(retries=2, retry_delay_secs=5, timeout_secs=3)\ndef send_reminder(user_id):\n    print(f\"Reminder sent to user {user_id}\")\n\n# Run once in 5 minutes\nsend_reminder.schedule(123, in_=timedelta(minutes=5))\n\n# Run every hour\nsend_reminder.schedule(123, interval=3600)\n\n# Cron-style: every Monday at 9am UTC\nsend_reminder.schedule(123, cron=\"0 9 * * MON\")\n</code></pre>"},{"location":"#whats-next","title":"What\u2019s Next?","text":"<ul> <li>Quickstart \u2192</li> <li>Configuration \u2192</li> <li>CLI \u2192</li> <li>Core Concepts \u2192</li> <li>Scheduler \u2192</li> <li>Plugin System \u2192</li> <li>Architecture \u2192</li> <li>Roadmap \u2192</li> <li>Contributing \u2192</li> <li>FAQ \u2192</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache 2.0 - open, reliable, and production-ready.</p>"},{"location":"architecture/","title":"Nuvom Architecture","text":"<p>Clean, predictable, and pluggable built for developers who value control and clarity.</p> <p>Nuvom is a plugin-first task engine for Python. Its architecture cleanly separates task definition, discovery, queuing, execution, and result storage with each layer following a well-defined contract.</p> <p>This makes it simple to start with zero external dependencies and equally simple to plug in Redis, PostgreSQL, or any custom backend as you scale.</p>"},{"location":"architecture/#high-level-overview","title":"High-Level Overview","text":"<pre><code>     +-------------------------+\n     |      @task decorator    |\n     +-------------------------+\n                  |\n                  v\n      +------------------------+\n      |     Task Registry      | &lt;--- loaded from manifest\n      +------------------------+\n                  |\n                  v\n+-------------+     +-------------------+\n| Dispatcher  | --&gt; |  Job Queue        |\n+-------------+     +-------------------+\n                         |\n                         v\n            +----------------------+ \n            |   Worker Pool        |\n            | (Threads + Runner)   |\n            +----------------------+ \n                         |\n                         v\n            +----------------------+ \n            |  Result Backend      |\n            +----------------------+ \n</code></pre>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#task-api","title":"Task API","text":"<p>Location: <code>nuvom/task.py</code></p> <ul> <li>The <code>@task</code> decorator registers a function as a Nuvom task.</li> <li>Metadata (like retries, timeouts, or result persistence) is attached at definition time.</li> <li>Exposes <code>.delay()</code>, <code>.map()</code>, and <code>.schedule()</code> for immediate, batched, or deferred execution.</li> </ul>"},{"location":"architecture/#task-discovery","title":"Task Discovery","text":"<p>Location: <code>nuvom/discovery/</code></p> <ul> <li>AST-based discovery ensures safe, import-free scanning.</li> <li>Uses <code>.nuvomignore</code> to skip irrelevant paths.</li> <li>Caches output to <code>.nuvom/manifest.json</code> for near-instant worker startup.</li> </ul> <p>Key modules:</p> <ul> <li><code>walker.py</code> \u2014 file traversal</li> <li><code>parser.py</code> \u2014 AST parsing</li> <li><code>manifest.py</code> \u2014 manifest I/O</li> <li><code>auto_register.py</code> \u2014 loads tasks into the registry</li> </ul>"},{"location":"architecture/#task-registry","title":"Task Registry","text":"<p>Location: <code>nuvom/registry/registry.py</code></p> <ul> <li>Thread-safe global registry.</li> <li>Prevents duplicate names unless <code>force=True</code>.</li> <li>Serves as the single source of truth for dispatchers and workers.</li> </ul>"},{"location":"architecture/#dispatcher","title":"Dispatcher","text":"<p>Location: <code>nuvom/dispatcher.py</code></p> <ul> <li>Serializes and enqueues jobs via a consistent interface.</li> <li>Uses <code>msgpack</code> for efficient, portable serialization.</li> <li>Powers <code>.delay()</code> and <code>.map()</code> to create jobs programmatically.</li> </ul>"},{"location":"architecture/#job-queues","title":"Job Queues","text":"<p>Location: <code>nuvom/queue_backends/</code></p> <p>Built-in backends:</p> <ul> <li><code>MemoryJobQueue</code></li> <li><code>FileJobQueue</code></li> <li><code>SQLiteJobQueue</code></li> </ul> <p>Custom queues follow a simple interface:</p> <pre><code>enqueue(job)\ndequeue(timeout=None)\npop_batch(batch_size)\nqsize()\nclear()\n</code></pre>"},{"location":"architecture/#workers-execution","title":"Workers &amp; Execution","text":"<p>Location: <code>nuvom/worker.py</code>, <code>nuvom/execution/job_runner.py</code></p> <ul> <li>Multi-threaded worker pool with controlled concurrency.</li> <li> <p>Executes jobs with:</p> </li> <li> <p>Timeouts</p> </li> <li>Retries</li> <li>Lifecycle hooks (<code>before_job</code>, <code>after_job</code>, <code>on_error</code>)</li> <li>Graceful shutdown with log flushing and clean teardown.</li> </ul>"},{"location":"architecture/#result-backends","title":"Result Backends","text":"<p>Location: <code>nuvom/result_backends/</code></p> <p>Built-in options:</p> <ul> <li><code>MemoryResultBackend</code></li> <li><code>FileResultBackend</code></li> <li><code>SQLiteResultBackend</code></li> </ul> <p>All result backends implement:</p> <pre><code>set_result(job_id, ...)\nget_result(job_id)\nset_error(job_id, ...)\nget_error(job_id)\nget_full(job_id)\nlist_jobs()\n</code></pre> <p>Custom result backends can be registered via <code>.nuvom_plugins.toml</code>.</p>"},{"location":"architecture/#logging","title":"Logging","text":"<p>Location: <code>nuvom/log.py</code></p> <ul> <li>Unified, developer-friendly logging built on <code>Rich</code>.</li> <li>Color-coded, exception-aware output for clean debugging and CLI visibility.</li> </ul>"},{"location":"architecture/#plugin-architecture","title":"Plugin Architecture","text":"<p>Location: <code>nuvom/plugins/</code></p> <ul> <li>Extend queues, result backends, or monitoring exporters.</li> <li>Lifecycle hooks: <code>start()</code> and <code>stop()</code> for controlled resource management.</li> </ul> <p>Example <code>.nuvom_plugins.toml</code>:</p> <pre><code>[plugins]\nqueue_backend = [\"custom.module:MyQueue\"]\nresult_backend = [\"custom.module:MyResult\"]\n</code></pre>"},{"location":"architecture/#job-lifecycle","title":"Job Lifecycle","text":"<ol> <li>Developer defines a task with <code>@task</code>.</li> <li><code>nuvom discover tasks</code> scans and caches it in the manifest.</li> <li>A job is queued using <code>.delay()</code>, <code>.map()</code>, or <code>.schedule()</code>.</li> <li>Worker dequeues the job.</li> <li> <p><code>JobRunner</code>:</p> </li> <li> <p>Fires lifecycle hooks</p> </li> <li>Executes the task with retry and timeout logic</li> <li>Stores result or error in the backend</li> <li>Result metadata can be queried via CLI or SDK.</li> </ol>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ul> <li>Clean separation \u2014 each layer has a single responsibility</li> <li>Pluggable by design \u2014 backends, metrics, and hooks are swappable</li> <li>Predictable behavior \u2014 no hidden daemons or background processes</li> <li>Cross-platform consistency \u2014 works the same on Linux, macOS, and Windows</li> <li>Readable source \u2014 easy to debug, easy to extend</li> </ul> <p>For more details:</p> <ul> <li>Contributing</li> <li>Roadmap</li> <li>README</li> </ul>"},{"location":"cli/","title":"Command-Line Interface (CLI)","text":"<p>Nuvom ships with a powerful developer-first CLI for running workers, inspecting jobs, managing plugins, and more.</p> <p>Run the following to get started:</p> <pre><code>nuvom --help\n</code></pre>"},{"location":"cli/#worker-control","title":"Worker Control","text":""},{"location":"cli/#start-worker-threads","title":"Start Worker Threads","text":"<pre><code>nuvom runworker\n</code></pre> <p>Starts the dispatcher and worker pool based on your <code>.env</code> settings.</p>"},{"location":"cli/#job-inspection-debugging","title":"Job Inspection &amp; Debugging","text":""},{"location":"cli/#inspect-job-result","title":"Inspect Job Result","text":"<pre><code>nuvom inspect job &lt;job_id&gt;\n</code></pre> <p>View full metadata, result, or traceback for a job.</p>"},{"location":"cli/#check-status","title":"Check Status","text":"<pre><code>nuvom status &lt;job_id&gt;\n</code></pre> <p>Quickly fetch a job\u2019s final status.</p>"},{"location":"cli/#view-recent-history","title":"View Recent History","text":"<pre><code>nuvom history recent --limit 10 --status SUCCESS\n</code></pre> <p>See recent jobs by filter or limit.</p>"},{"location":"cli/#task-discovery-listing","title":"Task Discovery &amp; Listing","text":""},{"location":"cli/#discover-tasks","title":"Discover Tasks","text":"<pre><code>nuvom discover tasks\n</code></pre> <p>Parses project source files using AST and updates the manifest.</p>"},{"location":"cli/#list-tasks","title":"List Tasks","text":"<pre><code>nuvom list tasks\n</code></pre> <p>Displays all available <code>@task</code> functions registered in the manifest.</p>"},{"location":"cli/#local-job-runner","title":"Local Job Runner","text":""},{"location":"cli/#run-job-locally-for-testing","title":"Run Job Locally (For Testing)","text":"<pre><code>nuvom runtestworker run --input myjob.json\n</code></pre> <p>Execute a job directly from a JSON file (offline, no queue).</p>"},{"location":"cli/#plugin-management","title":"Plugin Management","text":""},{"location":"cli/#test-plugins","title":"Test Plugins","text":"<pre><code>nuvom plugin test\n</code></pre> <p>Attempts to load all plugins from <code>.nuvom_plugins.toml</code> and verifies startup/shutdown.</p>"},{"location":"cli/#list-registered-plugins","title":"List Registered Plugins","text":"<pre><code>nuvom plugin status\n</code></pre> <p>Shows plugins currently registered by name and type.</p>"},{"location":"cli/#scaffold-plugin-stub","title":"Scaffold Plugin Stub","text":"<pre><code>nuvom plugin scaffold --type queue_backend --name my_plugin\n</code></pre> <p>Creates a boilerplate plugin file with the correct structure.</p>"},{"location":"cli/#configuration-helper","title":"Configuration Helper","text":"<pre><code>nuvom config\n</code></pre> <p>Prints all loaded environment variables and configuration values.</p>"},{"location":"cli/#tips","title":"\ud83d\udca1 Tips","text":"<ul> <li>Combine <code>discover tasks</code> and <code>list tasks</code> for troubleshooting discovery issues.</li> <li>Use <code>plugin test</code> if your backends aren\u2019t being picked up correctly.</li> <li><code>runtestworker</code> is useful for debugging serialization or runtime issues offline.</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Nuvom is built around a small number of powerful, composable concepts. Mastering these is key to using (and extending) the system effectively, now including built-in scheduling.</p>"},{"location":"concepts/#task","title":"Task","text":"<p>A <code>Task</code> is a Python function decorated with <code>@task(...)</code>. It becomes a job template.</p> <pre><code>@task(retries=2, timeout_secs=5)\ndef send_email(to, body):\n    ...\n</code></pre> <p>Each task carries metadata like retry policy, timeout, whether to store results, and scheduling configuration.</p>"},{"location":"concepts/#job","title":"Job","text":"<p>A <code>Job</code> is a serialized instance of a task + arguments.</p> <pre><code>job = send_email.delay(\"alice@example.com\", \"hello\")\n</code></pre> <p>Jobs are queued and executed by workers. You can inspect metadata, results, status, and tracebacks.</p>"},{"location":"concepts/#worker","title":"Worker","text":"<p>A Worker pulls jobs from the queue and executes them.</p> <p>Nuvom workers:</p> <ul> <li>Run in parallel (multi-threaded)</li> <li>Respect timeouts, retries, and lifecycle hooks</li> <li>Use safe shutdown behavior (<code>SIGINT</code> triggers graceful stop)</li> <li>Work with plugin-registered backends</li> <li>Execute scheduled jobs seamlessly, respecting intervals, cron expressions, and one-off timings</li> </ul> <p>Start a worker pool with:</p> <pre><code>nuvom runworker\n</code></pre>"},{"location":"concepts/#dispatcher","title":"Dispatcher","text":"<p>The Dispatcher converts function calls into jobs.</p> <ul> <li><code>.delay()</code> \u2192 single job</li> <li><code>.map()</code> \u2192 batch jobs</li> <li><code>.schedule()</code> \u2192 schedule jobs (one-off, interval, or cron)</li> <li>Supports metadata injection</li> <li>Automatically selects queue backend from config</li> </ul>"},{"location":"concepts/#queue-backend","title":"Queue Backend","text":"<p>A Queue Backend stores jobs awaiting execution.</p> <p>Built-in:</p> <ul> <li><code>MemoryJobQueue</code> \u2013 fast, ephemeral</li> <li><code>FileJobQueue</code> \u2013 atomic, file-based persistence</li> <li><code>SQLiteJobQueue</code> \u2013 relational queue with retries + visibility timeouts</li> </ul> <p>Custom backends can be added via plugins. Each queue implements:</p> <ul> <li><code>enqueue(job)</code></li> <li><code>dequeue(timeout)</code></li> <li><code>pop_batch(n)</code></li> <li><code>qsize()</code></li> <li><code>clear()</code></li> </ul>"},{"location":"concepts/#result-backend","title":"Result Backend","text":"<p>Stores results or errors from executed jobs.</p> <p>Built-in:</p> <ul> <li><code>MemoryResultBackend</code></li> <li><code>FileResultBackend</code></li> <li><code>SQLiteResultBackend</code></li> </ul> <p>Backends implement:</p> <ul> <li><code>set_result(id, func, result)</code></li> <li><code>set_error(id, func, exc)</code></li> <li><code>get_result(id)</code></li> <li><code>get_error(id)</code></li> <li><code>get_full(id)</code></li> <li><code>list_jobs()</code></li> </ul>"},{"location":"concepts/#registry","title":"Registry","text":"<p>The Task Registry maps task names \u2192 callables.</p> <ul> <li>Populated from <code>.nuvom/manifest.json</code></li> <li>Supports dynamic registration (<code>force</code>, <code>silent</code>)</li> <li>Used by workers to resolve jobs \u2192 functions</li> </ul>"},{"location":"concepts/#task-discovery","title":"Task Discovery","text":"<p>Uses AST parsing to find <code>@task</code> decorators.</p> <ul> <li>No runtime imports</li> <li>Supports <code>.nuvomignore</code></li> <li>Results cached in <code>.nuvom/manifest.json</code></li> <li>Updated via <code>nuvom discover tasks</code></li> </ul> <p>Enables fast startup and avoids circular imports.</p>"},{"location":"concepts/#scheduling","title":"Scheduling","text":"<p>Scheduling is built into Nuvom tasks:</p> <ul> <li>One-off: run once at a specific time</li> <li>Interval: run repeatedly at fixed intervals</li> <li>Cron: run with cron expressions</li> </ul> <p>Example:</p> <pre><code>from datetime import timedelta, datetime, timezone\n\n# Run once at a specific time\nsend_email.schedule(\"alice@example.com\", \"hello\", at=datetime(2025,8,25,12,0,tzinfo=timezone.utc))\n\n# Run once after 30 seconds\nsend_email.schedule(\"alice@example.com\", \"hello\", in_=timedelta(seconds=30))\n\n# Run every 5 minutes\nsend_email.schedule(\"alice@example.com\", \"hello\", interval=300)\n\n# Cron-style: daily at midnight UTC\nsend_email.schedule(\"alice@example.com\", \"hello\", cron=\"0 0 * * *\")\n</code></pre> <p>Scheduled jobs integrate seamlessly with workers, retries, and plugins.</p>"},{"location":"concepts/#plugins","title":"Plugins","text":"<p>Extend Nuvom dynamically:</p> <ul> <li>Queue backends</li> <li>Result backends</li> <li>Monitoring hooks</li> <li>Lifecycle-aware systems</li> </ul> <p>Defined in <code>.nuvom_plugins.toml</code> and validated with <code>nuvom plugin test</code>.</p>"},{"location":"concepts/#summary-table","title":"Summary Table","text":"Concept Role <code>@task</code> Defines metadata for background execution, including scheduling <code>Job</code> A task + args, queued for execution <code>Worker</code> Executes jobs from the queue, including scheduled jobs <code>Queue</code> Stores jobs awaiting execution <code>Backend</code> Stores results, errors, and metadata <code>Dispatcher</code> Converts function calls into jobs, supports <code>.delay()</code>, <code>.map()</code>, <code>.schedule()</code> <code>Registry</code> Maps task names to functions <code>Discovery</code> Scans source code and builds task manifest <code>Plugin</code> Dynamically extends Nuvom\u2019s capabilities <code>Scheduler</code> Manages one-off, interval, and cron jobs across workers"},{"location":"configuration/","title":"Nuvom Configuration Guide","text":"<p>Nuvom is fully configurable via environment variables and <code>.env</code> files. This guide explains supported settings, how they affect runtime behavior, and plugin integration, including the scheduler backend.</p>"},{"location":"configuration/#where-settings-come-from","title":"Where Settings Come From","text":"<p>Nuvom loads configuration in order of precedence:</p> <ol> <li><code>.env</code> file in your project root (via <code>pydantic-settings</code>)</li> <li>Environment variables (<code>export FOO=...</code>)</li> <li>Defaults defined in code if not overridden</li> </ol>"},{"location":"configuration/#example-env","title":"Example <code>.env</code>","text":"<pre><code>NUVOM_QUEUE_BACKEND=file\nNUVOM_RESULT_BACKEND=memory\nNUVOM_SERIALIZATION_BACKEND=msgpack\nNUVOM_SCHEDULER_BACKEND=file\n\nNUVOM_ENVIRONMENT=dev\nNUVOM_LOG_LEVEL=INFO\n\nNUVOM_MAX_WORKERS=4\nNUVOM_BATCH_SIZE=10\nNUVOM_JOB_TIMEOUT_SECS=30\nNUVOM_TIMEOUT_POLICY=retry\n\nNUVOM_MANIFEST_PATH=.nuvom/manifest.json\nNUVOM_SQLITE_QUEUE_PATH=.nuvom/queue.db\nNUVOM_SQLITE_RESULT_PATH=.nuvom/results.db\n</code></pre>"},{"location":"configuration/#core-configuration-variables","title":"Core Configuration Variables","text":"Variable Description Default <code>NUVOM_ENVIRONMENT</code> <code>dev</code>, <code>test</code>, or <code>prod</code> <code>dev</code> <code>NUVOM_LOG_LEVEL</code> Logging level: <code>DEBUG</code>, <code>INFO</code>, etc. <code>INFO</code> <code>NUVOM_QUEUE_BACKEND</code> Backend type: <code>memory</code>, <code>file</code>, <code>sqlite</code>, or plugin name <code>sqlite</code> <code>NUVOM_RESULT_BACKEND</code> Result store: <code>memory</code>, <code>file</code>, <code>sqlite</code>, or plugin name <code>sqlite</code> <code>NUVOM_SERIALIZATION_BACKEND</code> Format for job payloads (<code>msgpack</code>) <code>msgpack</code> <code>NUVOM_MANIFEST_PATH</code> Path to task discovery manifest <code>.nuvom/manifest.json</code> <code>NUVOM_JOB_TIMEOUT_SECS</code> Default job timeout (unless overridden in <code>@task</code>) <code>30</code> <code>NUVOM_BATCH_SIZE</code> Jobs pulled per worker cycle <code>10</code> <code>NUVOM_MAX_WORKERS</code> Number of worker threads <code>4</code> <code>NUVOM_TIMEOUT_POLICY</code> Behavior on timeout: <code>retry</code>, <code>fail</code>, <code>ignore</code> <code>retry</code> <code>NUVOM_SCHEDULER_BACKEND</code> Scheduler backend to use (<code>memory</code>, <code>redis</code>, <code>sqlite</code>, plugin) <code>sqlite</code>"},{"location":"configuration/#plugin-configuration","title":"Plugin Configuration","text":"<p>Plugins extend Nuvom dynamically and are registered via <code>.nuvom_plugins.toml</code>:</p> <pre><code>[plugins]\nqueue_backend = [\"my_module:MyQueuePlugin\"]\nresult_backend = [\"my_module:MyResultPlugin\"]\nscheduler_backend = [\"my_module:CustomSchedulerBackend\"]\nmonitoring = [\"nuvom.plugins.monitoring.prometheus:PrometheusPlugin\"]\n</code></pre> <p>Pass plugin-specific values via <code>.env</code>:</p> <pre><code>MY_PLUGIN_AUTH_TOKEN=abc123\n</code></pre> <p>Inside the plugin, access them via the <code>settings</code> argument passed to <code>start()</code>:</p> <pre><code>def start(self, settings):\n    token = settings.get(\"auth_token\", None)\n</code></pre>"},{"location":"configuration/#sqlite-backend-settings","title":"SQLite Backend Settings","text":"<p>For SQLite backends:</p> Variable Purpose Default <code>NUVOM_SQLITE_QUEUE_PATH</code> SQLite file path for job queue <code>.nuvom/queue.db</code> <code>NUVOM_SQLITE_RESULT_PATH</code> SQLite file path for result backend <code>.nuvom/results.db</code> <p>Directories are created automatically if missing.</p>"},{"location":"configuration/#cli-to-view-active-config","title":"CLI to View Active Config","text":"<pre><code>nuvom config\n</code></pre> <p>Example output:</p> <pre><code>Environment: dev\nQueue Backend: sqlite\nResult Backend: sqlite\nScheduler Backend: sqlite\nMax Workers: 4\nBatch Size: 10\nManifest Path: .nuvom/manifest.json\n...\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ul> <li>Commit <code>.env.example</code> for contributors</li> <li>Keep secrets out of version control (<code>.gitignore</code>)</li> <li>Override values in CI/CD via environment variables</li> <li>Use scheduler backends that match your production workload</li> <li>Verify configuration with <code>nuvom config</code></li> </ul>"},{"location":"configuration/#summary","title":"Summary","text":"<p>Nuvom gives developers clean, predictable, and extensible control over runtime behavior, queuing, results, plugins, and scheduling via a single scheduler backend variable.</p> <p>Developer-first, predictable, and professional configuration.</p>"},{"location":"contributing/","title":"Contributing to Nuvom","text":"<p>Thank you for considering contributing to Nuvom \u2014 a lightweight, plugin-first task execution engine.</p> <p>We welcome improvements in stability, performance, plugin support, documentation, bug fixes, and any enhancement that makes Nuvom a more reliable and developer-friendly tool.</p>"},{"location":"contributing/#project-setup-with-hatch","title":"Project Setup (with Hatch)","text":"<p>We use Hatch for managing environments, dependencies, testing, and packaging.</p>"},{"location":"contributing/#1-clone-the-repository","title":"1. Clone the repository","text":"<pre><code>git clone https://github.com/nahom-zewdu/Nuvom\ncd Nuvom\n</code></pre>"},{"location":"contributing/#2-install-hatch-once","title":"2. Install Hatch (once)","text":"<pre><code>pip install hatch\n</code></pre>"},{"location":"contributing/#3-enter-the-development-shell","title":"3. Enter the development shell","text":"<pre><code>hatch shell\n</code></pre> <p>This activates a fully isolated dev environment with all dependencies.</p>"},{"location":"contributing/#4-run-tests","title":"4. Run tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"contributing/#5-try-the-cli","title":"5. Try the CLI","text":"<pre><code>nuvom --help\n</code></pre>"},{"location":"contributing/#plugin-based-development","title":"Plugin-Based Development","text":"<p>Most Nuvom components are extensible via base interfaces and the <code>Plugin</code> protocol.</p>"},{"location":"contributing/#add-a-new-queue-backend","title":"\u2795 Add a New Queue Backend","text":"<ol> <li>Subclass <code>BaseJobQueue</code> from <code>nuvom.queue_backends.base</code>.</li> <li> <p>Implement:</p> </li> <li> <p><code>enqueue</code>, <code>dequeue</code>, <code>pop_batch</code>, <code>qsize</code>, <code>clear</code></p> </li> <li> <p>Register:</p> </li> <li> <p>via <code>.env</code>, or</p> </li> <li>via <code>.nuvom_plugins.toml</code> (preferred)</li> <li>Add tests under <code>tests/queue_backends/</code></li> </ol>"},{"location":"contributing/#add-a-new-result-backend","title":"\u2795 Add a New Result Backend","text":"<ol> <li>Subclass <code>BaseResultBackend</code> from <code>nuvom.result_backends.base</code>.</li> <li> <p>Implement:</p> </li> <li> <p><code>set_result</code>, <code>get_result</code>, <code>set_error</code>, <code>get_error</code>, <code>get_full</code>, <code>list_jobs</code></p> </li> <li>Register the plugin</li> <li>Add tests under <code>tests/result_backends/</code></li> </ol>"},{"location":"contributing/#plugin-testing","title":"Plugin Testing","text":"<p>Use the CLI to test plugin loading:</p> <pre><code>nuvom plugin status                      # Show all loaded plugins   \nnuvom plugin scaffold my_redis_backend   # Create plugin stub   \nnuvom plugin test nuvom_hello.plugin     # Test installed plugin   \nnuvom plugin test ./my_plugin.py         # Test from file\n</code></pre> <p>Example <code>.nuvom_plugins.toml</code>:</p> <pre><code>[plugins]\nqueue_backend = [\"my_module:MyQueuePlugin\"]\nresult_backend = [\"my_module:MyResultPlugin\"]\n</code></pre>"},{"location":"contributing/#testing-coverage","title":"Testing &amp; Coverage","text":"<p>We use <code>pytest</code>. All new features must include tests.</p> <pre><code>pytest\n</code></pre> <p>Test philosophy:</p> <ul> <li>Use actual backends in test cases</li> <li>Cover all logic branches, including edge/failure cases</li> <li>Include both CLI and programmatic tests</li> <li>For plugin tests, use isolated <code>.nuvom_plugins.toml</code> in a temp dir</li> </ul>"},{"location":"contributing/#code-style-linting","title":"Code Style &amp; Linting","text":"<p>Follow PEP8 and our project standards.</p>"},{"location":"contributing/#format-lint-code","title":"Format &amp; lint code","text":"<pre><code>hatch run fmt\n</code></pre> <p>Which runs:</p> <ul> <li><code>black .</code></li> <li><code>ruff check .</code></li> </ul> <p>See <code>pyproject.toml</code> for configuration.</p>"},{"location":"contributing/#logging-guidelines","title":"Logging Guidelines","text":"<ul> <li>Use <code>nuvom.log.logger</code>, not <code>print()</code></li> <li><code>logger.debug</code> \u2192 internals</li> <li><code>logger.info</code> \u2192 lifecycle events (e.g., job started)</li> <li><code>logger.error</code> \u2192 job or system failures</li> </ul>"},{"location":"contributing/#commit-conventions","title":"Commit Conventions","text":"<p>Use semantic, scoped commit messages. Examples:</p> <pre><code>feat(plugins): add dynamic plugin registry and loader\nfeat(result): support SQLite result backend\nfeat(worker): implement graceful shutdown logic\ntest(plugin): add test for plugin-registered backend\ndocs: update CONTRIBUTING for plugin architecture\n</code></pre>"},{"location":"contributing/#suggested-directory-layout","title":"Suggested Directory Layout","text":"<pre><code>nuvom/\n\u251c\u2500\u2500 cli/               # Typer CLI commands\n\u251c\u2500\u2500 queue_backends/    # Job queues (memory, SQLite, etc.)\n\u251c\u2500\u2500 result_backends/   # Task result stores\n\u251c\u2500\u2500 plugins/           # Loader, registry, capabilities\n\u251c\u2500\u2500 execution/         # JobRunner and context\n\u251c\u2500\u2500 discovery/         # Static task discovery logic\n\u251c\u2500\u2500 registry/          # Task registry and hook system\n\u251c\u2500\u2500 task.py            # @task decorator\n\u251c\u2500\u2500 config.py          # App config loader (pydantic)\n\u251c\u2500\u2500 log.py             # Rich-based logger\n\u251c\u2500\u2500 worker.py          # Worker pool, threading, retry\n</code></pre>"},{"location":"contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Think in small, testable units</li> <li>Prefer clarity over cleverness</li> <li>Avoid global state unless essential</li> <li>Use plugin-based injection when adding new backends</li> <li>Document public APIs with docstrings</li> <li>Follow the <code>Plugin</code> contract for lifecycle integration</li> </ul>"},{"location":"contributing/#code-review-process","title":"Code Review Process","text":"<ol> <li>Fork the repo, create a feature branch</li> <li>Add code and tests</li> <li>Submit a PR with a clear title and description</li> <li>A maintainer will review and provide feedback</li> <li>Once approved, the PR is merged into the main branch</li> </ol>"},{"location":"contributing/#need-help","title":"Need Help?","text":"<p>Feel free to open an issue \u2014 questions, bugs, and ideas are all welcome.</p> <p>Happy contributing! \ud83d\ude80\ud83e\udde0</p>"},{"location":"faq/","title":"Nuvom FAQ","text":"<p>Welcome to the Nuvom Frequently Asked Questions. This page answers common questions about how Nuvom works, why it was designed this way, and how to resolve potential issues.</p>"},{"location":"faq/#why-doesnt-nuvom-require-redis-or-a-message-broker","title":"Why doesn\u2019t Nuvom require Redis or a message broker?","text":"<p>Because it doesn\u2019t need one. Nuvom handles queuing and result persistence using pluggable local backends like memory, file, and SQLite.</p> <p>This keeps setup minimal \u2014 no servers, no daemons, no Docker.</p> <p>For larger or distributed use cases, Redis support is planned as a plugin.</p>"},{"location":"faq/#does-nuvom-run-on-windows","title":"Does Nuvom run on Windows?","text":"<p>Yes. Nuvom is 100% Windows-compatible \u2014 no reliance on POSIX signals, <code>fork()</code>, or Unix-only libraries. It works on Windows, Linux, and macOS out of the box.</p>"},{"location":"faq/#how-does-task-discovery-work-without-importing-modules","title":"How does task discovery work without importing modules?","text":"<p>Nuvom uses AST parsing to detect <code>@task</code> decorators. This means:</p> <ul> <li>No need to import modules</li> <li>No side effects from imports</li> <li>Safe even in large codebases</li> <li>Fast and cacheable (<code>.nuvom/manifest.json</code>)</li> </ul>"},{"location":"faq/#why-isnt-my-task-showing-up","title":"Why isn\u2019t my task showing up?","text":"<p>Check the following:</p> <ul> <li>Did you run <code>nuvom discover tasks</code>?</li> <li>Is the file skipped by <code>.nuvomignore</code>?</li> <li>Is the task defined with <code>@task</code> (not a typo)?</li> <li>Is the file inside your current working directory?</li> </ul> <p>You can always inspect the manifest manually at <code>.nuvom/manifest.json</code>.</p>"},{"location":"faq/#my-job-failed-how-do-i-retry-it","title":"My job failed. How do I retry it?","text":"<p>Use either the CLI or the SDK:</p> <p>CLI:</p> <pre><code>nuvom inspect job &lt;job_id&gt;\nnuvom retry job &lt;job_id&gt;\n</code></pre> <p>Python:</p> <pre><code>from nuvom.sdk import retry_job\nretry_job(\"&lt;job_id&gt;\")\n</code></pre>"},{"location":"faq/#how-do-timeouts-and-retries-work","title":"How do timeouts and retries work?","text":"<p>Each task can define:</p> <ul> <li><code>timeout_secs</code>: max execution time</li> <li><code>retries</code>: max retry attempts</li> <li><code>retry_delay_secs</code>: wait between retries</li> <li><code>timeout_policy</code>: <code>retry</code>, <code>fail</code>, or <code>ignore</code></li> </ul> <p>If a task times out or fails, Nuvom uses these fields to determine what happens next.</p>"},{"location":"faq/#how-do-i-test-my-plugins","title":"How do I test my plugins?","text":"<p>Use the plugin testing CLI:</p> <pre><code>nuvom plugin status                      # Show all loaded plugins\nnuvom plugin test nuvom_hello.plugin     # Test installed plugin   \nnuvom plugin test ./my_plugin.py         # Test from file\n</code></pre> <p>Make sure your <code>.nuvom_plugins.toml</code> file points to a valid Python module implementing the <code>Plugin</code> protocol.</p>"},{"location":"faq/#where-is-job-data-stored","title":"Where is job data stored?","text":"<p>Depends on your backend:</p> <ul> <li>Memory backend: stored in RAM (temporary)</li> <li>File backend: stored under <code>.nuvom/jobs/</code></li> <li>SQLite backend: stored in <code>.nuvom/result.db</code> or as configured</li> </ul> <p>Use <code>.env</code> to control storage location and backend type.</p>"},{"location":"faq/#my-job-runs-fine-manually-but-fails-in-the-worker","title":"My job runs fine manually, but fails in the worker","text":"<p>This usually means:</p> <ul> <li>The task file isn\u2019t discovered (use <code>nuvom discover tasks</code>)</li> <li>You have code that assumes global state or one-time imports</li> <li>The environment differs (missing <code>.env</code> vars or dependencies)</li> </ul> <p>Try running:</p> <pre><code>nuvom runtestworker run --job-file myjob.json\n</code></pre> <p>This simulates a worker run locally.</p>"},{"location":"faq/#what-can-i-build-with-plugins","title":"What can I build with plugins?","text":"<p>Anything:</p> <ul> <li>Queue backends (e.g., SQLite, Redis, custom API)</li> <li>Result backends (file, SQL, S3, etc.)</li> <li>Monitoring exporters (Prometheus, JSON logs)</li> <li>CLI extensions or pre/post-run hooks</li> </ul> <p>Nuvom's plugin system supports dynamic registration and lifecycle events (<code>start()</code>, <code>stop()</code>).</p>"},{"location":"faq/#does-nuvom-support-distributed-workers","title":"Does Nuvom support distributed workers?","text":"<p>Not yet. Current backends (memory, file, SQLite) are designed for single-host or single-disk usage.</p> <p>Distributed execution (e.g., multiple machines) will require network-aware backends like Redis or Postgres \u2014 coming in post\u2011v1 releases.</p>"},{"location":"faq/#got-a-question-thats-not-listed","title":"Got a question that\u2019s not listed?","text":"<p>Open an issue on GitHub or reach out via the project discussion board. We\u2019ll update this page as real-world usage evolves.</p>"},{"location":"plugins/","title":"Plugin System","text":"<p>Nuvom v0.9 introduced first-class plugin support \u2014 allowing developers to register their own backends, extensions, and instrumentation layers with clean lifecycle management.</p>"},{"location":"plugins/#what-is-a-plugin","title":"What is a Plugin?","text":"<p>A plugin is a Python class that implements the <code>Plugin</code> protocol, defining:</p> <ul> <li><code>name</code>: Unique plugin name</li> <li><code>provides</code>: What kind of capability it offers (e.g. <code>queue_backend</code>, <code>monitoring</code>)</li> <li><code>start(settings: dict)</code>: Initialization logic</li> <li><code>stop()</code>: Cleanup logic on shutdown</li> </ul>"},{"location":"plugins/#file-layout","title":"File Layout","text":"<p>Plugins can live inside your project or in external libraries. Common layout:</p> <pre><code>my_project/\n\u251c\u2500\u2500 plugins/\n\u2502   \u251c\u2500\u2500 my_plugin.py       # Your plugin logic\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 .nuvom_plugins.toml    # Plugin registration\n</code></pre>"},{"location":"plugins/#plugin-example-custom-queue-backend","title":"Plugin Example: Custom Queue Backend","text":"<pre><code># plugins/my_queue.py\nfrom nuvom.queue_backends.base import BaseJobQueue\nfrom nuvom.plugins.contracts import Plugin\n\nclass MyQueue(BaseJobQueue):\n    def enqueue(self, job): ...\n    def dequeue(self, timeout=None): ...\n    def pop_batch(self, n): ...\n    def qsize(self): ...\n    def clear(self): ...\n\nclass MyPlugin(Plugin):\n    name = \"my_queue\"\n    provides = [\"queue_backend\"]\n\n    def start(self, settings):\n        from nuvom.plugins.registry import register_queue_backend\n        register_queue_backend(\"my_custom_queue\", MyQueue)\n\n    def stop(self):\n        pass\n</code></pre> <p>Then register in <code>.nuvom_plugins.toml</code>:</p> <pre><code>[plugins]\nqueue_backend = [\"plugins.my_queue:MyPlugin\"]\n</code></pre>"},{"location":"plugins/#plugin-registry","title":"Plugin Registry","text":"<p>Nuvom loads plugins at worker startup (not during CLI commands).</p> <p>Each plugin is discovered from <code>.nuvom_plugins.toml</code>, instantiated, and injected with runtime settings.</p> <p>To test plugin loading:</p> <pre><code>nuvom plugin test\nnuvom plugin list\nnuvom plugin inspect my_queue\n</code></pre>"},{"location":"plugins/#plugin-lifecycle","title":"Plugin Lifecycle","text":"<p>Each plugin receives a <code>start(settings)</code> call when the worker starts.</p> <p>Example use cases:</p> <ul> <li>Registering new backends</li> <li>Spawning monitoring threads</li> <li>Configuring metrics exporters</li> <li>Connecting to databases</li> </ul> <p>On shutdown (<code>CTRL+C</code>, SIGINT), plugins receive a <code>stop()</code> call to clean up.</p>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":"Provides Purpose <code>queue_backend</code> Add a new job queue implementation <code>result_backend</code> Add a result/error store <code>monitoring</code> Expose runtime metrics (e.g. Prometheus) <code>lifecycle_hook</code> Run logic on job events (future)"},{"location":"plugins/#monitoring-plugin-example","title":"Monitoring Plugin Example","text":"<pre><code># plugins/prometheus_exporter.py\nfrom nuvom.plugins.contracts import Plugin\nfrom nuvom.plugins.registry import register_metrics_provider\n\nclass PrometheusPlugin(Plugin):\n    name = \"prometheus\"\n    provides = [\"monitoring\"]\n\n    def start(self, settings):\n        from my_exporter import run_exporter\n        run_exporter(port=settings.get(\"prometheus_port\", 9150))\n\n    def stop(self):\n        ...\n</code></pre>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ul> <li>Keep plugins self-contained.</li> <li>Use <code>settings</code> from <code>.env</code> or custom sources.</li> <li>Fail fast if required dependencies are missing.</li> <li>Avoid blocking inside <code>start()</code> \u2014 spawn threads if needed.</li> <li>Don\u2019t forget <code>stop()</code> for graceful cleanup.</li> </ul>"},{"location":"plugins/#cli-support","title":"CLI Support","text":"Command Description <code>nuvom plugin test</code> Validates and loads plugins <code>nuvom plugin list</code> Lists registered plugin types <code>nuvom plugin inspect</code> Shows metadata for one plugin"},{"location":"plugins/#roadmap-future-plugin-hooks","title":"Roadmap (Future Plugin Hooks)","text":"Feature Status <code>before_job</code>, <code>after_job</code> [ ] Planned (via plugin) <code>metrics_provider</code> interface \u2705 Prometheus supported CLI plugin extensions [ ] Future Multi-process plugin runners [ ] Future"},{"location":"plugins/#summary","title":"Summary","text":"<p>Plugins allow you to:</p> <ul> <li>Add new backends (queue, result)</li> <li>Hook into Nuvom\u2019s lifecycle</li> <li>Export runtime metrics</li> <li>Customize behavior without modifying Nuvom core</li> </ul> <p>Plugins make Nuvom truly pluggable. Add what you need \u2014 nothing more.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide walks you through installing Nuvom, defining your first task, scheduling it, and running workers all in under 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install nuvom\n</code></pre>"},{"location":"quickstart/#1-define-a-task","title":"1. Define a Task","text":"<p>Tasks are regular Python functions decorated with <code>@task</code>:</p> <pre><code># tasks.py\nfrom nuvom.task import task\n\n@task(retries=2, retry_delay_secs=5, timeout_secs=3, store_result=True)\ndef add(x, y):\n    return x + y\n</code></pre> <p>The decorator enables retry logic, timeouts, and lets you dispatch with <code>.delay()</code> or <code>.map()</code>.</p>"},{"location":"quickstart/#2-discover-tasks-optional-but-recommended","title":"2. Discover Tasks (Optional but Recommended)","text":"<p>Nuvom uses static AST-based discovery to find task definitions without executing your code.</p> <p>Run once:</p> <pre><code>nuvom discover tasks\n</code></pre> <p>This generates <code>.nuvom/manifest.json</code> to speed up worker startup and avoid runtime imports.</p>"},{"location":"quickstart/#3-submit-a-job-immediately","title":"3. Submit a Job Immediately","text":"<p>Dispatch jobs programmatically:</p> <pre><code>from tasks import add\n\njob = add.delay(5, 7)\nprint(job.id)\n</code></pre>"},{"location":"quickstart/#4-schedule-a-task","title":"4. Schedule a Task","text":"<p>Tasks expose <code>.schedule()</code> for deferred or recurring execution. Scheduling works seamlessly across workers and backends.</p> <pre><code>from datetime import timedelta, datetime, timezone\nfrom tasks import add\n\n# Run at a specific time (2038 iykyk)\nadd.schedule(5, 7, at=datetime(2038, 1, 19, 3, 14, 7, tzinfo=timezone.utc)) \n\n# Run once after 30 seconds\nadd.schedule(5, 7, in_=timedelta(seconds=30))\n\n# Run every 5 minutes (interval scheduling)\nadd.schedule(2, 3, interval=300)\n\n# Cron-style: every day at midnight UTC\nadd.schedule(1, 2, cron=\"0 0 * * *\")\n</code></pre> <p>Start the scheduler service:</p> <pre><code>nuvom runscheduler\n</code></pre> <p>Workers will automatically execute due jobs.</p>"},{"location":"quickstart/#5-run-a-worker","title":"5. Run a Worker","text":"<p>Workers execute jobs in parallel threads:</p> <pre><code>nuvom runworker\n</code></pre> <p>You can configure worker behavior (count, batch size, scheduler backend, etc.) via <code>.env</code>. See Configuration for details.</p>"},{"location":"quickstart/#6-inspect-job-status","title":"6. Inspect Job Status","text":"<pre><code>nuvom inspect job &lt;job_id&gt;\n</code></pre> <p>This shows result, error, traceback, retries remaining, and timestamps.</p> <p>To view recent jobs:</p> <pre><code>nuvom history recent --limit 10\n</code></pre>"},{"location":"quickstart/#7-retry-failed-jobs","title":"7. Retry Failed Jobs","text":"<p>Retry manually from Python:</p> <pre><code>from nuvom.sdk import retry_job\n\nretry_job(\"&lt;job_id&gt;\")\n</code></pre> <p>CLI support for retrying is available in the next release.</p>"},{"location":"roadmap/","title":"Nuvom Roadmap","text":"<p>This document outlines Nuvom\u2019s development milestones, from initial prototype to the current release, and what\u2019s ahead for v1.0 and beyond.</p> <p>Nuvom is built to be a developer-first, plugin-friendly, and predictable task execution engine. We\u2019re designing for real-world problems across local development, production, and Windows environments \u2014 with clarity, extensibility, and reliability at the core.</p>"},{"location":"roadmap/#completed-milestones","title":"Completed Milestones","text":""},{"location":"roadmap/#v01-core-foundations","title":"v0.1 \u2014 Core Foundations","text":"<ul> <li>Basic <code>@task()</code> decorator with <code>.delay()</code></li> <li>In-memory queue and worker threads</li> <li>Functional CLI: <code>nuvom runworker</code>, <code>nuvom list tasks</code></li> </ul>"},{"location":"roadmap/#v02-result-backends-cli","title":"v0.2 \u2014 Result Backends &amp; CLI","text":"<ul> <li>Pluggable result backend interface</li> <li>File-based result store</li> <li>Full CLI inspection commands</li> </ul>"},{"location":"roadmap/#v03-queue-backends","title":"v0.3 \u2014 Queue Backends","text":"<ul> <li>File-based persistent job queue</li> <li>Msgpack serialization for jobs</li> <li><code>.corrupt</code> quarantine for bad jobs</li> </ul>"},{"location":"roadmap/#v04-runtime-execution-hooks","title":"v0.4 \u2014 Runtime Execution &amp; Hooks","text":"<ul> <li><code>ExecutionEngine</code> abstraction</li> <li>Timeout and retries</li> <li>Lifecycle hooks: <code>before_job</code>, <code>after_job</code>, <code>on_error</code></li> </ul>"},{"location":"roadmap/#v05-static-task-discovery","title":"v0.5 \u2014 Static Task Discovery","text":"<ul> <li>AST-powered task detection</li> <li><code>.nuvomignore</code> support</li> <li>Manifest system for caching task metadata</li> </ul>"},{"location":"roadmap/#v06-developer-experience-boosts","title":"v0.6 \u2014 Developer Experience Boosts","text":"<ul> <li>Dev mode (<code>--dev</code>) for hot task reloading</li> <li>Manifest diffing and CLI-rich task listings</li> <li>Structured logs and tracebacks via <code>rich</code></li> </ul>"},{"location":"roadmap/#v07-observability-history","title":"v0.7 \u2014 Observability &amp; History","text":"<ul> <li>Tracebacks for all jobs</li> <li>Full CLI metadata inspection</li> <li>Historical job browsing</li> </ul>"},{"location":"roadmap/#v08-reliability-and-polish","title":"v0.8 \u2014 Reliability and Polish","text":"<ul> <li>Retry-on-failure system</li> <li>Timeout policy: <code>retry</code>, <code>fail</code>, <code>ignore</code></li> <li>SDK retry tools</li> <li>Job attempt metadata and diagnostics</li> </ul>"},{"location":"roadmap/#v09-plugin-architecture-sqlite","title":"v0.9 \u2014 Plugin Architecture + SQLite","text":"<ul> <li>Fully dynamic plugin system via <code>.nuvom_plugins.toml</code></li> <li>SQLite result backend</li> <li>Graceful shutdown lifecycle for plugin-based workers</li> <li>Plugin-based test coverage</li> </ul>"},{"location":"roadmap/#v010-pre-v1-foundation","title":"v0.10 \u2014 Pre-v1 Foundation","text":"<ul> <li>SQLite-based persistent queue backend</li> <li>Visibility timeout &amp; requeue support</li> <li>Plugin regression test suite</li> <li>Built-in Prometheus metrics plugin</li> <li>MkDocs documentation site</li> <li>Performance &amp; concurrency benchmarking</li> <li>Plugin lifecycle: <code>start(settings)</code>, <code>stop()</code></li> <li>Queue introspection metrics: <code>queue_size</code>, <code>inflight_jobs</code></li> <li>Final polish + bugfixes for v0.10 release</li> </ul>"},{"location":"roadmap/#v011-scheduler-production-ready-apis","title":"v0.11 \u2014 Scheduler &amp; Production-Ready APIs","text":"<p>Status: Current release</p> <ul> <li>Built-in scheduler for one-off, interval, and cron-style tasks</li> <li><code>.schedule()</code> API integrated with tasks, compatible with workers</li> <li>Scheduler backend support via environment variable</li> <li>Predictable execution across local and production environments</li> <li>CLI and SDK support for scheduling inspection</li> <li>Minor bugfixes and cross-platform stability improvements</li> <li>Documentation updates with scheduling guides</li> </ul>"},{"location":"roadmap/#v10-goals-stable-core","title":"v1.0 Goals \u2014 Stable Core","text":"<ul> <li>[x] Windows-native, Redis-free by design</li> <li>[x] No imports required: safe task discovery via AST</li> <li>[x] CLI-driven, scriptable, and testable</li> <li>[x] Plugin-first queue &amp; result architecture</li> <li>[x] Observability, retries, and timeouts</li> <li>[x] Queue system stress-tested for multi-core workloads</li> <li>[ ] Plugin registry contracts + third-party plugin showcase</li> <li>[ ] Rich dashboard and metrics browser</li> </ul>"},{"location":"roadmap/#post10-backlog-ideas","title":"Post\u20111.0 Backlog (Ideas)","text":"<p>These features are actively under exploration \u2014 not committed to a specific release:</p> <ul> <li>[ ] Redis queue and result backend (optional, opt-in)</li> <li>[ ] Multi-host worker cluster (via file locks or RPC mesh)</li> <li>[ ] DAG-style task chaining: <code>task1().then(task2)</code></li> <li>[ ] Plugin sandboxing and capability enforcement</li> <li>[ ] Web UI / dashboard to browse queue + workers</li> <li>[ ] VSCode extension: discover tasks visually, browse results</li> <li>[ ] Task versioning and signature integrity check</li> <li>[ ] Offline <code>.nuvom_tasks.json</code> static task export (zero-import bootstrap)</li> </ul>"},{"location":"roadmap/#contributing","title":"Contributing","text":"<p>The roadmap is shaped by real-world problems. Open an issue or discussion if:</p> <ul> <li>You need support for a custom backend</li> <li>You\u2019re building a dashboard or monitoring tool</li> <li>You\u2019re using Nuvom at scale and hitting edge cases</li> <li>You want to build your own plugin or backend</li> </ul> <p>Let\u2019s build something lean, sharp, and predictable \u2014 together.</p>"},{"location":"scheduler/","title":"Nuvom Scheduling Guide","text":"<p>Scheduling in Nuvom is a first-class citizen. It works just like <code>.delay()</code>, but defers execution for the future or sets up recurring tasks. Jobs are stored in a scheduler backend, and workers execute them when they become due.</p>"},{"location":"scheduler/#1-concepts","title":"1. Concepts","text":""},{"location":"scheduler/#schedule-envelope","title":"Schedule Envelope","text":"<p>When you call <code>.schedule()</code>, Nuvom wraps your task call in a ScheduleEnvelope:</p> <ul> <li>Contains task name, args/kwargs, schedule type, next run timestamp, and metadata</li> <li>Stored in the scheduler backend (a separate queue from the main job queue)</li> <li>Scheduler service reads due envelopes and pushes jobs to the main queue</li> </ul> <p>This abstraction allows reliable, recurring, and time-zone aware scheduling without burdening the worker logic.</p>"},{"location":"scheduler/#scheduling-types","title":"Scheduling Types","text":"Type Description Backend Behavior <code>one_off</code> Single execution at a specific time (<code>at</code>) or after a delay (<code>in_</code>) Removed after dispatch <code>interval</code> Recurring execution every N seconds (<code>interval</code>) Next run rescheduled automatically <code>cron</code> Recurring execution following a cron expression (<code>cron</code>) Scheduler computes next fire time according to timezone"},{"location":"scheduler/#2-api-reference","title":"2. API Reference","text":"<pre><code>Task.schedule(\n    *args,\n    at: datetime | None = None,\n    in_: timedelta | None = None,\n    interval: int | None = None,\n    cron: str | None = None,\n    timezone_name: str | None = \"UTC\",\n    **kwargs,\n) -&gt; ScheduleEnvelope\n</code></pre>"},{"location":"scheduler/#parameters","title":"Parameters","text":"<ul> <li><code>*args, **kwargs</code> \u2014 Arguments passed to the task when executed</li> <li><code>at</code> \u2014 Absolute UTC-aware datetime for one-off execution</li> <li><code>in_</code> \u2014 Relative <code>timedelta</code> from now for one-off execution</li> <li><code>interval</code> \u2014 Seconds between recurring runs; must be &gt;0</li> <li><code>cron</code> \u2014 Standard cron string (e.g., <code>\"0 9 * * MON\"</code>)</li> <li><code>timezone_name</code> \u2014 IANA timezone for cron evaluation; defaults to <code>\"UTC\"</code></li> </ul> <p>Note: Exactly one of <code>at</code>, <code>in_</code>, <code>interval</code>, or <code>cron</code> must be provided.</p>"},{"location":"scheduler/#returns","title":"Returns","text":"<ul> <li><code>ScheduleEnvelope</code> \u2014 Backend-storable object representing your scheduled task</li> </ul>"},{"location":"scheduler/#3-examples","title":"3. Examples","text":""},{"location":"scheduler/#one-off-execution","title":"One-off execution","text":"<pre><code>from datetime import datetime, timezone, timedelta\nfrom tasks import add\n\n# Absolute time\nadd.schedule(5, 7, at=datetime(2025, 8, 25, 12, 0, tzinfo=timezone.utc))\n\n# Relative time\nadd.schedule(5, 7, in_=timedelta(seconds=30))\n</code></pre>"},{"location":"scheduler/#interval-execution","title":"Interval execution","text":"<pre><code># Run every 5 minutes\nadd.schedule(2, 3, interval=300)\n</code></pre>"},{"location":"scheduler/#cron-execution","title":"Cron execution","text":"<pre><code># Run every Monday at 9 AM UTC\nadd.schedule(1, 2, cron=\"0 9 * * MON\")\n</code></pre>"},{"location":"scheduler/#4-scheduler-service","title":"4. Scheduler Service","text":"<p>The scheduler backend stores scheduled tasks separately from the main queue. To execute them:</p> <pre><code>nuvom runscheduler\n</code></pre> <ul> <li>Reads <code>ScheduleEnvelope</code> objects that are due</li> <li>Pushes jobs to the main queue for worker consumption</li> <li>Reschedules interval and cron tasks automatically</li> <li>Supports multiple scheduler instances safely in production</li> </ul>"},{"location":"scheduler/#5-advanced-notes","title":"5. Advanced Notes","text":""},{"location":"scheduler/#time-zones","title":"Time Zones","text":"<ul> <li>Cron expressions can be evaluated in any IANA timezone</li> <li>Naive <code>datetime</code> objects in <code>at</code> are assumed UTC with a warning</li> </ul>"},{"location":"scheduler/#failure-resilience","title":"Failure &amp; Resilience","text":"<ul> <li>One-off tasks are removed after execution</li> <li>Interval tasks are rescheduled automatically, even if the previous run failed</li> <li>Scheduler backend implementations can persist envelopes to disk, database, or memory</li> </ul>"},{"location":"scheduler/#extensibility","title":"Extensibility","text":"<ul> <li>Custom scheduler backends can be implemented by providing <code>enqueue()</code>, <code>get()</code>, <code>due()</code>, <code>reschedule()</code>, and <code>cancel()</code> methods</li> <li>Fully compatible with Nuvom\u2019s plugin system</li> </ul>"},{"location":"scheduler/#6-best-practices","title":"6. Best Practices","text":"<ul> <li>Use <code>.schedule()</code> over <code>.delay()</code> for long-running or recurring tasks</li> <li>Combine <code>.schedule(interval=...)</code> with <code>store_result=True</code> to track recurring job outcomes</li> <li>Keep <code>cron</code> expressions timezone-aware for production deployments</li> </ul>"}]}